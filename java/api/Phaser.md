### Phaser()
**jdk 1.7新增**

一个可重用的同步屏障,在功能上类似于`CyclicBarrier`和`CountDownLatch`,但支持更灵活的使用.  
**注册**: 与其他屏障的情况不同,在相位器上注册同步的各方数量可能会随着时间的推移而变化. 任务可以在任何时候注册(使用方法`register`,`bulkRegister`,或构造函数的形式来建立初始方数),也可以在任何到达时取消注册(使用`arriveAndDeregister`). 与大多数基本同步结构的情况一样,
注册和注销只影响内部计数,它们不建立任何进一步的内部簿记,因此任务无法查询它们是否已注册.(但是,您可以通过子类化这个类来引入这种簿记)  
**同步**: 就像循环屏障(`CyclicBarrier`)一样,相位器可能会被反复等待. 方法`arriveAndAwaitAdvance`的作用类似于`CyclicBarrier.await`. 相位器的每一代具有相关联的相位(`phase`)数. 相位数从0开始,并在所有各方到达相位器时前进,在达到`Integer.MAX_VALUE`后重新回到0. 
相位号的使用可以通过两种方法独立控制到达相位器和等待其他相位器时的动作,这两种方法可以由任何注册方调用:
+ `arrival`. 方法`arrive`和`arriveAndDeregister`记录到达,这些方法不会阻塞,而是返回一个相关联的到达相位号,也就是说,接收到的相位器的相位数.当给定阶段的最后一方到达时,将执行一个可选操作,并继续该阶段.这些操作由触发阶段推进的一方执行，并通过重写方法onAdvance(int, int)来安排，该方法也控制终止。重写此方法类似于为CyclicBarrier提供屏障操作，但比提供屏障操作更灵活。
+ `Waiting`. 方法awaitAdvance需要一个参数来指示到达阶段号，并在相位器前进到(或已经处于)另一个阶段时返回。与使用CyclicBarrier的类似结构不同，即使等待线程被中断，方法awaitAdvance也会继续等待。可中断和超时版本也可用，但在任务可中断等待或超时等待时遇到的异常不会改变相位器的状态。如果有必要，您可以在这些异常的处理程序中执行任何相关的恢复，通常是在调用forceTermination之后。在ForkJoinPool中执行的任务也可以使用Phasers，这将确保在其他任务被阻塞等待阶段推进时执行任务的足够并行性。

