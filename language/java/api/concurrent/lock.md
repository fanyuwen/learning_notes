### 为什么aqs要采用双端队列进行等待线程的存储
> 双向链表有两个指针,前驱指针和后驱指针,所以双向链表能保证在插入和删除节点的时候要比单向链表更加简单和高效
> 1. 当一个没有竞争到锁的线程需要等待获取锁的过程当中加入到阻塞队列并且阻塞等待的一个前提是,当前等待节点的前置节点是一个正常状态(waitStatus是默认)
>    这样设计的目的是为了避免存在异常状态的节点,导致无法唤醒后续的节点线程,所以线程在阻塞之前需要判断前置节点的状态,如果没有前置节点的引用,那么
>    就需要从头节点开始遍历,这个效率是很低的
> 2. 在AbstractQueuedSynchronizer里有一个可以响应中断的获取锁的方式,它表示处于阻塞等待获取锁的线程是允许被中断的,也就是没有获取到锁的线程
>    在加入到同步队列之后是可以被外部的线程通过interrupt方法去唤醒和中断的,但是这个被中断唤醒的线程节点的waitStatus会被更新为cancelled状态
>    他是不需要去竞争锁的,但是它仍然存在于双向链表里面,意味着后续的锁的竞争需要把这个节点从链表中移除,否则会导致阻塞等待的线程没法被正常唤醒,这种
>    情况如果是单向链表,就需要从头节点开始遍历,找到并移除异常状态的节点,这种效率是很低的,而且还会又锁唤醒的操作和遍历操作之间的竞争
> 3. 为了避免线程阻塞和唤醒的开销,新加入链表的线程会首先通过自旋的方式去尝试竞争锁,但是实际上按照公平锁的设计,只有头节点的下一个节点才有必要去竞争锁
>    后续的节点去竞争锁的意义不大,否则会造成**惊群效应**(大量的线程去竞争锁,最终只有一个线程能获取到,这会带来比较大的性能开销),所以为了避免这个问题
>    加入到链表里面的节点在尝试竞争锁的时候,需要去判断前置节点是不是头节点,如果不是头节点就没有必要去触发锁的竞争动作,所以会设计前置节点的查找,如果是
>    单向链表是无法实现这样的功能的

### LockSupport与Object.wait/notify,Condition.await/signal的区别
> 今天也是在看aqs(`AbstractQueuedSynchronizer`)的源码的时候发现的,其实已经就注意了,只是这次在研究共享(share)模式的时候额外注意了一下,`Object.wait/Condition.await`等待
> 与对应的`Object.notify/Condition.signal`唤醒之间是有严格的先后关系的,可以参考java语言规范里*happen-before*原则,理论上`Object.wait/Condition.await` happen before
> `Object.notify/Condition.signal,所以notify或者signal只能唤醒之气wait或者await的线程,而不能唤醒之后的,而`LockSupport`则不一样,他是有一个被称为许可(permit)的条件,我猜测
> 是一个数字,当调用park系方法是,会相应的加/减许可数,调用unpark系方法时会减/加许可数,当许可数为0时表示线程可以正常运行