# 订单支付超时-方案梳理
1. jdk DelayQueue
    ```java
        public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
            implements BlockingQueue<E> {}
    
        public interface Delayed extends Comparable<Delayed> {
            long getDelay(TimeUnit unit);
        }
    ```
    它本身就是一个队列,队列里的元素必须要实现Delayed,实现getDelay方法代表元素的超时时间,队列通过方法返回的值进行优先级定位(PriorityQueue),当你在获取队列元素的时候,如果第一个元素的getDelay方法返回小于等于0,则说明
    超时时间已经到了,直接返回,否则根据调用的方法的不同会返回null(poll)/抛异常(remove)/阻塞(take),
    主要实现就是通过一个固定的线程不停地轮询这个队列的头部,如果订单超时了,就能够获取到超时的订单并进行处理
    
    优点:简单,不需要借助其他第三方组件,成本低(适用于单体应用,并发量和数据量不大)
    缺点: 1. DelayQueue是存在于应用内存中的,所以如果应用重启,则之前的所有存入的数据都没有了
         2. 所有超时处理订单都要加到DelayQueue中,占用内存大
         3. 没法做到分布式处理,只能在集群中选一台leader专门处理,效率低
         4. 不适合订单量很大的场景
        
2. mq 延时消息
   消息生产者发送一个定时消息(额外指定定时时间)给消息中间件的终端,当到达了指定的时间,终端就会把这个消息发送给监听的消费者,消费者可以获取到订单的信息,然后进行业务处理
   如果整体的数据量并不是像大厂那种级别的数据量可以考虑
   优点:1.使用简单,和使用普通消息一样
       2.支持分布式
       3.精度高,支持任意时刻
   缺点:1.使用限制,定时时长最大值24个小时
       2.成本高,每个订单需要新增一个定时消息,且不会马上消费,给mq带来很大的存储成本
       3.同一时刻大量消息会导致消息延迟,定时消息的实现逻辑需要先经过定时存储等待触发,定时时间到达后才会被投递给消费者,因此
         如果将大量定时消息的定时时间设置为同一时刻,则到达该时刻后会有大量消息同时需要被处理,造成系统压力过大,导致消息分发延迟,
         影响定时精度(甚至导致降低mq的可用性,需要运维对该mq投入精力维护它的可靠性 可用性)
3. redis 过期监听
   需要单独对redis开启过期回调监听,新增一个订单,往redis中添加一个key和一个过期时间,当过期时间到了,可以通过一个单独的redis过期时间监听回调实现
   来处理业务,更新对应的订单状态,(整体上的方案设计和实现跟mq差不多)所以如果业务的并发量和数据量并没有达到一定级别,可以考虑采用
   优点:同mq
   缺点:(中间件的缺点)
       1.不可靠(不是100%可靠),redis在过期通知的时候,如果应用刚好重启,就可能导致事件丢失,业务订单无法关闭,稳定性也有问题,所以如果一定要采取该方案
         建议通过定时任务做补偿机制
       2.如果订单量大需要占用中间件大量的存储空间,需要额外的维护成本
4. 定时任务分布式批处理
   采用主流的分布式定时任务中间件(quartz/xxl-job/schedulerX)+单独的定时任务存储数据库(如果是人力和精力有实力的可以做一个超时处理中心平台,线上业务将订单超时数据存一份到本数据库),实现思路就是在一个定时任务当中,
   去实现一个指定时间的一个定时任务,当达到时间,就实现具体的业务逻辑(处理订单超时),批量地查询所有超时的时间,批量地更新到数据库,需要就是单批次的数据处理要足够快
   优点:稳定性高,不会存在订单执行丢失的情况,即使第一次没有处理到该订单,下一次到执行周期内依然会去该订单
       效率高,采用批量处理的方式,能提高海量数据的处理效率,相比之前的一条一条处理来说,效率是高很多的
       运维性高,中间件你要保证它的高可用 高可靠,这个是需要花费额外很多精力的,而针对本方案只是需要修改数据库里的数据
       成本低,相比中间件的使用(中间件集群),本方案的成本更低
   缺点:精确度稍低,它的精确度需要靠你定时任务的定时周期来保证,但是这个时间也不能设置的很小,容易对数据造成很大的负载压力(还会影响线上正常的业务),
5. 一般性总结: 如果就是一个单体的应用,并且也没有数据量的压力,就可以直接考虑单线程循环DelayQueue的方式去实现 
             如果对于超时精度比较高,超时时间在24小时内,且不会有峰值压力的场景,推荐使用mq的定时消息解决方案
             在类电商业务下,许多订单超时场景都在24小时以上,对于超时精度没有那么敏感,并且有海量订单需要批处理,推荐使用基于定时任务的批处理解决方案